<!DOCTYPE html>
<html lang="en">
	<head>
		<title>The Black Fractal - threejs.test</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="css/main.css">
	</head>

	<body>

		<video id="xenoVideo" loop crossOrigin="anonymous" playsinline style="display:none">
			<source src="./video/XenogothikaPromo.mp4" type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'>
		</video>
		<video id="artScreen01" loop crossOrigin="anonymous" playsinline style="display:none">
			<source src="./video/Neurowalker.mp4" type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'>
		</video>

		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

			import { OrbitControls } from './examples/jsm/controls/OrbitControls.js';
			import { GLTFLoader } from './examples/jsm/loaders/GLTFLoader.js';
			import { RGBELoader } from './examples/jsm/loaders/RGBELoader.js';
			import { EffectComposer } from './examples/jsm/postprocessing/EffectComposer.js';
			import { RenderPass } from './examples/jsm/postprocessing/RenderPass.js';
			import { UnrealBloomPass } from './examples/jsm/postprocessing/UnrealBloomPass.js';
			import { LightProbeGenerator } from './examples/jsm/lights/LightProbeGenerator.js';

			let camera, scene, renderer, composer;

			let mixer;

			let lightProbe;

			let cubeCamera, cubeRenderTarget;

			let xenoVideo, artScreen01;

			var xenoVideoOn = false;
			var artScreen01On = false;


			let width, height;


			const API = {
				lightProbeIntensity: 1.0,
				directionalLightIntensity: 0.2,
				envMapIntensity: 1
			};

			const clock = new THREE.Clock();

			const params = {
				exposure: 1,
				bloomStrength: 1,
				bloomThreshold: 1,
				bloomRadius: 1
			};

			init();
			render();
			//animate();

			function init() {

				const container = document.createElement( 'div' );
				document.body.appendChild( container );

				//Camera

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 5000 );
				camera.position.set( - 25, 5, -25 );

				scene = new THREE.Scene();

				//Video

				xenoVideo = document.getElementById( 'xenoVideo' );
				artScreen01 = document.getElementById( 'artScreen01' );
				

				let vidPromoTexture = new THREE.VideoTexture( xenoVideo );
				vidPromoTexture.minFilter = THREE.NearestFilter;
				vidPromoTexture.magFilter = THREE.LinearFilter;
				vidPromoTexture.format = THREE.RGBAFormat;

				let vidMaterial   = new THREE.MeshBasicMaterial( { map : vidPromoTexture } );

				let artScreen01Texture = new THREE.VideoTexture( artScreen01 );
				artScreen01Texture.minFilter = THREE.NearestFilter;
				artScreen01Texture.magFilter = THREE.LinearFilter;
				artScreen01Texture.format = THREE.RGBAFormat;

				let artScreen01Material   = new THREE.MeshBasicMaterial( { map : artScreen01Texture } );

				//Environment
				
		

				const rgbeloader = new RGBELoader()
					.setPath( 'textures/equirectangular/' )
					.load( 'GreySky_2K.hdr', function ( texture ) {

						texture.mapping = THREE.EquirectangularReflectionMapping;

						scene.background = texture;
						scene.environment = texture;

						render();
						//animate();

						

						

					} );


			//	cubeRenderTarget = new THREE.WebGLCubeRenderTarget( 256, { format: THREE.RGBFormat, generateMipmaps: true, minFilter: THREE.LinearMipmapLinearFilter } );
			//	cubeRenderTarget.texture.type = THREE.HalfFloatType;

			//	cubeCamera = new THREE.CubeCamera( 5, 10000, cubeRenderTarget );
			//	scene.add( cubeCamera );
			

				//Loader

				const loader = new GLTFLoader().setPath( 'models/glb/' );
					loader.load( 'LanternSite.glb', function ( gltf ) {

					const model = gltf.scene;
					model.position.set( 0, 0, 0 );
					model.scale.set( 3, 3, 3 );

					model.traverse( function ( child ) {

       				   if ( child.isMesh ) {

         				child.material.shading = THREE.SmoothShading;
       		   		    child.castShadow = true;
      			        child.receiveShadow = true;
					 //   child.material.envMap = cubeRenderTarget.texture;						

							 if (child.name == "prScreen") {

                                child.material = vidMaterial;

				         	}

							 if (child.name == "ArtScreen01") {

								child.material = artScreen01Material;

							}

							if(child.name == "Cube003"){
								
								var newColor = new THREE.Color(5, 5, 5);
								child.material.color = newColor;
								child.material.tonemapped = false;
								
							}

         				 }});

					scene.add( model );

					

					

					mixer = new THREE.AnimationMixer( model );
					mixer.clipAction( gltf.animations[ 0 ] ).play();
					mixer.clipAction( gltf.animations[ 1 ] ).play();
					mixer.clipAction( gltf.animations[ 2 ] ).play();
					mixer.clipAction( gltf.animations[ 3 ] ).play();
					mixer.clipAction( gltf.animations[ 4 ] ).play();

					animate();

					} 
					
					);

				//Renderer

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.toneMapping = THREE.LinearToneMapping;
				renderer.toneMappingExposure = params.exposure;
				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.PCFSoftShadowMap;
				renderer.outputEncoding = THREE.sRGBEncoding;
				container.appendChild( renderer.domElement );



				

				//Controls

				const controls = new OrbitControls( camera, renderer.domElement );
				//controls.addEventListener( 'change', render ); // use if there is no animation loop
				controls.minDistance = 0.1;
				controls.maxDistance = 1000;
				controls.target.set( 0, 0, 0 );
				controls.update();

				// Probe
				lightProbe = new THREE.LightProbe();
				scene.add( lightProbe );


				//Lights

				scene.add( new THREE.AmbientLight( 0x252525 ) );

				const spotLight = new THREE.SpotLight( 0xffffff, 0.5 );
				spotLight.position.set( 300, 50, 0 );

				spotLight.castShadow = true;

				spotLight.shadow.mapSize.width = 1024;
				spotLight.shadow.mapSize.height = 1024;

				spotLight.shadow.camera.near = 0.1;
				spotLight.shadow.camera.far = 5000;
				spotLight.shadow.camera.fov = 60;

				const topLight = new THREE.PointLight( 0x00ff10, 1 );
				topLight.position.set( 50, 0, 0 );

				const lowLight = new THREE.PointLight( 0xff00eb, 1 );
				lowLight.position.set( -50, 0, 0 );

				const top1Light = new THREE.PointLight( 0xfffe00, 1);
				topLight.position.set( 0, 0, 50 );

				const low1Light = new THREE.SpotLight( 0xE70000, 1, 100, 90);
				lowLight.position.set( 50, 0, -50 );
				

				scene.add( spotLight );
				scene.add( topLight );
				scene.add( lowLight );
			    scene.add( top1Light );
				scene.add( low1Light );
				

				const renderScene = new RenderPass( scene, camera );

				const bloomPass = new UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.4, 0.85 );
				bloomPass.threshold = params.bloomThreshold;
				bloomPass.strength = params.bloomStrength;
				bloomPass.radius = params.bloomRadius;

				composer = new EffectComposer( renderer );
				composer.addPass( renderScene );
				composer.addPass( bloomPass );

				
				window.addEventListener( 'resize', onWindowResize );

			}

				const raycaster = new THREE.Raycaster();
				const mouse = new THREE.Vector2()

				renderer.domElement.addEventListener( 'click', onClick, false );


			function onClick() {
				event.preventDefault();

				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

				raycaster.setFromCamera( mouse, camera );

				var intersects = raycaster.intersectObjects( scene.children, true );

				if ( intersects.length > 0 ) {
				    console.log( 'Intersection:', intersects[ 0 ] );
					console.log( intersects[ 0 ].object.name, intersects[ 0 ] );	

					if(intersects[0].object.name=="OpenseaButton_2") {
						window.open('https://opensea.io/collection/the-black-fractal')
					}	

					if(intersects[0].object.name=="TwitterButton_2") {
						window.open('https://twitter.com/theblackfractal')
					}

					if(intersects[0].object.name=="DiscordButton_2") {
						window.open('https://discordapp.com/users/theblackfractal#8976')
					}

					if(intersects[0].object.name=="VoxArmsButton_2") {
						window.open('https://opensea.io/collection/black-fractal-voxels')
					}

					//Main Screen

					if(intersects[0].object.name=="prScreen") {

						if(xenoVideoOn == false){

						xenoVideo.play();
						xenoVideo.addEventListener( 'play', function () {

						this.currentTime = 0;

						} );

						xenoVideoOn = true;
						console.log( 'xenoVideoOn' );

						}

						else{

							xenoVideo.pause();

							xenoVideoOn = false;
							console.log( 'xenoVideoOff' );
							
						}
						
					}

					//Art Screen 01

					if(intersects[0].object.name=="ArtScreen01") {

						if(artScreen01On == false){

							artScreen01.play();
							artScreen01.addEventListener( 'play', function () {

						this.currentTime = 0;

						} );

						artScreen01On = true;
						console.log( 'artScreen01On' );

						}

						else{

							artScreen01.pause();

						artScreen01On = false;
						console.log( 'artScreen01Off' );
	
						}

					}
				}
			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
				composer.setSize( width, height );

				animate();

			}

			//

			function render() {

				//renderer.render( scene, camera );
				//composer.render();

			}

			function animate() {

					requestAnimationFrame( animate );

					const delta = clock.getDelta();

					mixer.update( delta );

				//	cubeCamera.update( renderer, scene );

					renderer.render( scene, camera );

					composer.render(animate);

					

			}

		</script>

	</body>
</html>